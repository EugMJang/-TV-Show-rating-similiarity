# Goals
In our project, we are using data found on the anime-tracking website MyAnimeList in order to create a graph of different anime and how closely different users rate them.  Edges are created between anime who users tend to rate fairly similarly.  The CSV file we used was created in python from a bigger csv file of every rating ever, with only the top 1001 most popular anime being put into our graph.  We intended, after creating this, to create a force-directed graph to nicely image our data set, and to implement BFS and Dijkstra's algorithm in order to tell the similarities between different anime.  The main function we have provided in this repository creates both a force directed graph, and outputs BFS and Dijkstra's algorithm based on user inputs.  Test cases have been provided that tested the workings of our algorithms on much smaller datasets (the dataset we normally use has 1001 nodes).
# Force-Directed Graph
"ForceGraph.png" shows the results that we obtained for the Force-Directed Graph Drawing. In this graph, the size of the node indicates the general favorability of the "tv show": a bigger node means more favorable. The distance between each node is determined by the average rating difference between two "tv shows". Immediately when looking at the Force-Directed graph, we can tell that there is one giant clump of "tv shows" that are closely connected with each other. Most of these "tv show" are popular "tv show" that are liked by the general public. This clump of "tv show" is surprisingly linear, which could have been caused by the creation of some sort of polarity, with relatively favorable "tv show" on one end, and less favorable "tv show" on the other. Inside of this clump of "tv show" are smaller clumps of "tv show": these represent genres of "tv shows" that people have rated similarly.

# BFS
BFS did not give us as much as much data as we thought it would. This is largely due to the fact that each node is mostly connected to a lot of the other nodes. Therefore, the BFS order is very similar to the order that each "tv show" is listed in the CSV. If we did this in the future, one way that this could be resolved is by further fiddling with the threshold value that determines whether to make an edge between the two nodes, so that not every node is connected to each other. 

# Dijkstra's
Dijkstra's runtime was much longer than expected. This is probably because the nodes in our graph have many connections with other nodes, and Dijkstra needs to find the shortest path between these connections. Similar to our conclusions with BFS, if we attempted to use Dijkstra's algorithm in the future, we would adjust the threshold value that decides the existence of an edge between two nodes so that there are less connections per each node and the runtime is much more efficient.
